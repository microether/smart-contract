// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MicroLoan {

    enum RepaymentMethod { Monthly, Quarterly, Yearly }
    enum CollateralType { Social, Uncollateralised }
    
    struct Loan {
        uint256 loanAmount;
        uint256 dueDate;
        RepaymentMethod repaymentMethod;
        CollateralType collateralType;
        address payable borrower;
        address[] guarantors;
        bool isFunded;
    }

    uint256 public loanCounter = 0;
    mapping(uint256 => Loan) public loans;

    event LoanApplied(uint256 loanId, address indexed borrower);
    event LoanGuaranteed(uint256 loanId, address indexed guarantor);
    event LoanFunded(uint256 loanId);

    function applyForLoan(
        uint256 _loanAmount,
        uint256 _dueDate,
        RepaymentMethod _repaymentMethod,
        CollateralType _collateralType
    ) external returns(uint256) {
        Loan memory newLoan = Loan({
            loanAmount: _collateralType == CollateralType.Social ? _loanAmount : _loanAmount / 2, // Example: Uncollateralised loans can only get half the amount
            dueDate: _dueDate,
            repaymentMethod: _repaymentMethod,
            collateralType: _collateralType,
            borrower: payable(msg.sender),
            guarantors: new address[](0),
            isFunded: false
        });

        loanCounter++;
        loans[loanCounter] = newLoan;
        
        emit LoanApplied(loanCounter, msg.sender);

        return loanCounter;
    }

    function guaranteeLoan(uint256 _loanId) external {
        require(loans[_loanId].collateralType == CollateralType.Social, "Loan doesn't support social collateral");
        require(loans[_loanId].guarantors.length < 10, "Already have enough guarantors");
        loans[_loanId].guarantors.push(msg.sender);

        if (loans[_loanId].guarantors.length == 10) {
            payoutLoanAmount(_loanId);
        }

        emit LoanGuaranteed(_loanId, msg.sender);
    }

    function payoutLoanAmount(uint256 _loanId) internal {
        require(!loans[_loanId].isFunded, "Loan already funded");
        require(loans[_loanId].collateralType == CollateralType.Uncollateralised || loans[_loanId].guarantors.length == 10, "Not enough guarantors");
        
        loans[_loanId].isFunded = true;
        loans[_loanId].borrower.transfer(loans[_loanId].loanAmount);

        emit LoanFunded(_loanId);
    }

    function checkAndTriggerWithdrawal(uint256 _loanId) external {
        require(block.timestamp >= loans[_loanId].dueDate, "Loan is not due yet");
        // Add logic for checking borrower's balance and triggering the withdrawal.
    }

    // This function allows to add funds to the contract
    function addFunds() external payable {}
}
