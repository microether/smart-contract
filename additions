// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MicroLoan {

    enum RepaymentMethod { Monthly, Quarterly, Yearly }
    enum LoanType { Uncollateralized, SocialCollateral }

    struct Loan {
        uint256 amount;
        uint256 dueDate;
        RepaymentMethod repaymentMethod;
        LoanType loanType;
        uint8 numGuarantors; // New field to store the number of desired guarantors.
        uint8 actualGuarantors; // Actual guarantors who vouched.
        bool isFunded;
    }

    uint256 private loanIDCounter = 0;
    mapping(address => uint256) public creditScores;
    mapping(uint256 => Loan) public loans;
    mapping(uint256 => address[]) public loanGuarantors;

    uint256 constant MIN_GUARANTORS = 10;
    int constant UNC_COLLATERAL_THRESHOLD = 50;
    int constant SCORE_DECREASE_BORROWER = 40;
    int constant SCORE_INCREASE_BORROWER = 10;
    int constant SCORE_DECREASE_GUARANTOR = 10;
    int constant SCORE_INCREASE_GUARANTOR = 2;
    int constant MINIMUM_SCORE = -70;
    int constant MAX_SCORE = 100;

    event LoanApplied(uint256 loanId, address indexed borrower);
    event LoanGuaranteed(uint256 loanId, address indexed guarantor);
    event LoanFunded(uint256 loanId);

    constructor() {
        // Set initial credit score for new users
        creditScores[msg.sender] = 0;
    }

    function calculateInterestRate(address borrower, LoanType collateral) private view returns (uint256) {
        int score = creditScores[borrower];
        
        // Sample dynamic interest rate calculation
        if(collateral == LoanType.SocialCollateral) {
            if(score > 80) return 2; // 2%
            else if(score > 60) return 4; 
            else return 6;
        } else {
            if(score > 80) return 10; 
            else if(score > 60) return 12; 
            else return 15;
        }
    }

    function applyForLoan(
        uint256 _loanAmount,
        uint256 _dueDate,
        RepaymentMethod _repaymentMethod,
        LoanType _loanType,
        uint8 _numGuarantors // New parameter for desired number of guarantors.
    ) public returns (uint256) {
        require(creditScores[msg.sender] >= -70, "Credit score too low");
        require(_numGuarantors >= 1 && _numGuarantors <= 20, "Invalid number of guarantors");
        
        if(_loanType == LoanType.Uncollateralized) {
            require(creditScores[msg.sender] > 50, "Credit score not sufficient for uncollateralized loan");
        } else if(_loanType == LoanType.SocialCollateral) {
            creditScores[msg.sender] += _numGuarantors; // Increase credit score for each guarantor chosen.
            if (creditScores[msg.sender] > 100) {
                creditScores[msg.sender] = 100; // Cap credit score at 100.
            }
        }

        loanIDCounter++;
        loans[loanIDCounter] = Loan({
            amount: _loanAmount,
            dueDate: _dueDate,
            repaymentMethod: _repaymentMethod,
            loanType: _loanType,
            numGuarantors: _numGuarantors,
            actualGuarantors: 0,
            isFunded: false
        });
        return loanIDCounter;
    }

    function guaranteeLoan(uint256 _loanId) external {
        require(loans[_loanId].collateralType == CollateralType.Social, "Only social collateral loans can be guaranteed");
        require(loans[_loanId].guarantors.length < MIN_GUARANTORS, "This loan already has enough guarantors");

        loans[_loanId].guarantors.push(msg.sender);
        emit LoanGuaranteed(_loanId, msg.sender);

        if (loans[_loanId].guarantors.length == MIN_GUARANTORS) {
            loans[_loanId].isFunded = true;
            uint256 totalAmount = loans[_loanId].loanAmount + ((loans[_loanId].loanAmount * loans[_loanId].interestRate) / 100);
            loans[_loanId].borrower.transfer(totalAmount);
            emit LoanFunded(_loanId);
        }
    }

    function repayLoan(uint256 _loanId) external payable {
        require(msg.sender == loans[_loanId].borrower, "Only the borrower can repay");
        uint256 expectedRepayment = loans[_loanId].loanAmount + ((loans[_loanId].loanAmount * loans[_loanId].interestRate) / 100);
        require(msg.value == expectedRepayment, "Incorrect repayment amount");

        if (block.timestamp <= loans[_loanId].dueDate) {
            creditScore[msg.sender] += SCORE_INCREASE_BORROWER;
            for (uint256 i = 0; i < loans[_loanId].guarantors.length; i++) {
                creditScore[loans[_loanId].guarantors[i]] += SCORE_INCREASE_GUARANTOR;
            }
        } else {
            creditScore[msg.sender] -= SCORE_DECREASE_BORROWER;
            for (uint256 i = 0; i < loans[_loanId].guarantors.length; i++) {
                creditScore[loans[_loanId].guarantors[i]] -= SCORE_DECREASE_GUARANTOR;
            }
        }
    }


    function vouchForLoan(uint256 _loanID) public {
        Loan storage loan = loans[_loanID];
        require(loan.loanType == LoanType.SocialCollateral, "Can only vouch for social collateral loans");
        require(loan.actualGuarantors < loan.numGuarantors, "Already has enough guarantors");

        loanGuarantors[_loanID].push(msg.sender);
        loan.actualGuarantors++;

        if (loan.actualGuarantors == loan.numGuarantors) {
            // If desired number of guarantors is reached, you can implement funding logic here.
        }
    }


    function addFunds() external payable {}

    receive() external payable {}
}
